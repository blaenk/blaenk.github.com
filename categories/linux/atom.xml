<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Jorge Israel Peña]]></title>
  <link href="http://blaenkdenum.com/categories/linux/atom.xml" rel="self"/>
  <link href="http://blaenkdenum.com/"/>
  <updated>2013-03-22T20:41:40-07:00</updated>
  <id>http://blaenkdenum.com/</id>
  <author>
    <name><![CDATA[Jorge Israel Peña]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Linux Programming Interface: Directories and Links]]></title>
    <link href="http://blaenkdenum.com/posts/the-linux-programming-interface-directories-and-links/"/>
    <updated>2013-03-06T17:40:00-08:00</updated>
    <id>http://blaenkdenum.com/posts/the-linux-programming-interface-directories-and-links</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#directories">Directories</a></li>
  <li><a href="#hard-links">Hard Links</a>    <ul>
      <li><a href="#shared-pointers">Shared Pointers</a></li>
      <li><a href="#temporary-files">Temporary Files</a></li>
    </ul>
  </li>
  <li><a href="#symbolic-links">Symbolic Links</a></li>
  <li><a href="#directory-streams">Directory Streams</a></li>
  <li><a href="#working-directories">Working Directories</a></li>
  <li><a href="#root-directories">Root Directories</a></li>
</ul>

<p>Notes for chapter 18 concerning directories and links.</p>

<h2 id="directories">Directories</h2>

<p>Stored in the file system as a regular file except:</p>

<ol>
  <li>marked differently in its i-node entry</li>
  <li>data content is a table mapping filenames to i-node numbers</li>
</ol>

<h2 id="hard-links">Hard Links</h2>

<p>Hard links are also referred to simply as ‘links’. It is soft links which require additional qualification. Links can be created using the <code>ln</code> command which is often used to instead create soft (symbolic) links (<code>ln -s</code>). Creating a hard link to a file doesn’t copy (<code>cp</code>) the file itself, instead it creates a different filename pointing to the same i-node number and also increases the ‘link count’ of the file. This can be verified by running <code>ls -li</code> to see each file’s corresponding i-node number and link count.</p>

<p>Hard links can’t be made to directories, thereby preventing circular links. The book recounts how early UNIX implementations did allow this in order to facilitate directory creation. <a href="http://man7.org/linux/man-pages/man2/mkdir.2.html"><code>mkdir</code></a> didn’t exist, so directories were created with <a href="http://man7.org/linux/man-pages/man2/mknod.2.html"><code>mknod</code></a> and then links were made for <code>.</code> and <code>..</code> to facilitate directory traversal. It also reminds the reader that ‘links to directories’ are more or less possible with bind mounts.</p>

<h3 id="shared-pointers">Shared Pointers</h3>

<p>Hard links remind me of <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><code>shared_ptr</code></a> in C++11. I can imagine a scenario in which different processes need access to a common file but the common file needs to be deleted when all processes are finished with it. They can create a link to the file and use that to do their work, since it will be the same file as the original. When they are finished with the file, they can <a href="http://man7.org/linux/man-pages/man2/unlink.2.html"><code>unlink</code></a> – remove the link – to the file. The file system will automatically delete the file itself when the number of links has reached zero. I don’t know if this is common – or even a correct – practice, nevertheless I immediately thought of this when I came across links.</p>

<h3 id="temporary-files">Temporary Files</h3>

<p>A trick in the spirit of the above is touched upon by the book. It talks about how a program might sometimes create a file, <code>unlink</code> it immediately, and then continue using the file knowing that the file will be destroyed 1) explicitly when the file descriptor is closed or 2) implicitly when the program closes. This is what <a href="http://man7.org/linux/man-pages/man3/tmpfile.3.html"><code>tmpfile</code></a> does.</p>

<h2 id="symbolic-links">Symbolic Links</h2>

<p>Also known as soft links, these types of links are more commonly used by people. They simply consist of the <code>type</code> i-node field being set to <code>symlink</code> and the data blocks of the i-node set to the target path.</p>

<p>An interesting note discussed by the book is that some UNIX file systems (such as ext2, ext3, and ext4) perform an optimization where, if the target path can fit in the part of the i-node that would normally be used for data-block pointers, the path is simply stored there instead of externally. In the case of the author, the ext filesystems appropriate 60 bytes to the data-block pointers. Analysis of his system showed that of the 20,070 symbolic links, 97% were 60 bytes or smaller.</p>

<h2 id="directory-streams">Directory Streams</h2>

<p>Directory entries can be enumerated by getting a directory stream handle with <a href="http://man7.org/linux/man-pages/man3/opendir.3.html"><code>opendir</code></a> (or <code>fdopendir</code> to avoid certain race conditions) and pulling directory entries <code>dirent</code> from the directory stream with <a href="http://man7.org/linux/man-pages/man2/readdir.2.html"><code>readdir</code></a>.</p>

<p>Additionally, recursive file tree walking can be achieved using <a href="http://man7.org/linux/man-pages/man3/ftw.3.html"><code>nftw</code></a> (new file tree walking) by passing it a callback to call on every entry.</p>

<h2 id="working-directories">Working Directories</h2>

<p>The working directory (<a href="http://man7.org/linux/man-pages/man3/getcwd.3.html"><code>getcwd</code></a>) of a process determines the reference point from which to resolve relative pathnames within the process. For example if the working directory is <code>/home/user</code> then a a file path of <code>../user2</code> will refer to <code>/home/user2</code>. Simple stuff. The working directory can be changed with <a href="http://man7.org/linux/man-pages/man2/chdir.2.html"><code>chdir</code></a> and <code>fchdir</code>.</p>

<p>Aside from this, Linux (&gt; 2.6.16) provides various <code>*at()</code> calls, such as <a href="http://man7.org/linux/man-pages/man2/openat.2.html"><code>openat</code></a>, which operate relative to a directory file descriptor. These calls (now part of SuSv4) help avoid certain race conditions and help facilitate an idea of “virtual working directories” which is particularly useful in multithreaded applications since every thread shares the working directory attribute of the process.</p>

<h2 id="root-directories">Root Directories</h2>

<p>Every process also has a root directory which serves as the reference point from which to resolve <em>absolute</em> pathnames (as opposed to relative pathnames with working directories). This is usually <code>/</code>, but can be changed with <a href="http://man7.org/linux/man-pages/man2/chroot.2.html"><code>chroot</code></a>, which is often used to create so called “chroot jails”, something FTP servers might do to limit a user’s filesystem exposure to their home directory.  One thing to remember to do is to change the working directory to the chrooted path, in effect “stepping into the jail.” Otherwise the user is able to continue roaming around outside the jail.</p>

<p>chroot jails aren’t a silver bullet. Some BSD derivatives provide a systemcall, <a href="http://www.freebsd.org/cgi/man.cgi?query=jail&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+9.1-RELEASE&amp;arch=default&amp;format=html"><code>jail</code></a>, that handles various edge cases.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XMonad Ignores Bindings]]></title>
    <link href="http://blaenkdenum.com/posts/xmonad-ignores-bindings/"/>
    <updated>2013-02-24T22:25:00-08:00</updated>
    <id>http://blaenkdenum.com/posts/xmonad-ignores-bindings</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#media-keys">Media Keys</a></li>
  <li><a href="#binding">Binding</a></li>
  <li><a href="#the-problem">The Problem</a></li>
  <li><a href="#bug-hunting">Bug Hunting</a></li>
  <li><a href="#workaround">Workaround</a></li>
  <li><a href="#bug-report">Bug Report</a></li>
</ul>

<p><strong>Disclaimer</strong>: This post is titled to make it easy for people who are experiencing the same problem to find this post. XMonad does <em>not</em> ignore <em>all</em> bindings.</p>

<p>In my <a href="/posts/terminal-customization/">previous post</a> I talked about how I spent a while configuring my system, specifically urxvt and zsh, in preparation for setting up <a href="http://xmonad.org">XMonad</a>. I’ve finally gotten around to setting up XMonad. One problem in particular stopped me from continuing with the rest of the configuration.</p>

<h2 id="media-keys">Media Keys</h2>

<p>I have a regular keyboard layout, <a href="http://www.daskeyboard.com/model-s-ultimate/">Das Keyboard Model S Ultimate</a>, which lacks media keys (i.e. volume up, down, etc). This wasn’t too much of a problem when I used headsets because most of them have dedicated volume controls. However, I got tired of headsets being rendered useless when any little thing messed up (e.g. microphone, a speaker, etc).</p>

<p>As a result I ended up buying a <a href="http://amzn.com/B00029MTMQ">cheap standalone mic</a> and now use my iPhone’s <a href="http://amzn.com/B004PNZFZ8">Shure SE215-K</a> earbuds for sound on my computer. This is very easy to do given my computer case’ front panel audio connector. Of course, the problem now is that there aren’t any dedicated media keys and having to use a GUI to change the volume is cumbersome.</p>

<p>My solution to this problem in Windows and Mac is to bind the bottom right keys to media keys as follows:</p>

<ul>
  <li>Right Control → Volume Up</li>
  <li>Menu Key → Volume Down</li>
  <li>Right Windows Key → Volume Mute</li>
</ul>

<h2 id="binding">Binding</h2>

<p>Creating these binds is possible on Windows via a registry hack, facilitated using a program such as <a href="http://www.randyrants.com/sharpkeys/">SharpKeys</a>.</p>

<p>On Linux I initially did this using <code>xmodmap</code>:</p>

<p>``` plain
remove Control = Control_R
keycode 105 = XF86AudioRaiseVolume
add Control = Control_R</p>

<p>keycode 135 = XF86AudioLowerVolume</p>

<p>remove mod4 = Super_R
keycode 134 = XF86AudioMute
add mod4 = Super_R
```</p>

<p>Binding to these <code>XF86Audio*</code> keys automatically adds support for these keys in different applications like <a href="http://www.mplayer2.org/">mplayer2</a>, but I wanted system-wide volume support. This is typically accomplished by wiring them up in your given Desktop Environment or Window Manager. So I went ahead and did so in <code>xmonad.hs</code>:</p>

<p><code>haskell
((0, xF86XK_AudioMute), spawn "amixer -q set Master,0 toggle"),
((0, xF86XK_AudioLowerVolume), spawn "amixer -q set Master,0 5%- unmute"),
((0, xF86XK_AudioRaiseVolume), spawn "amixer -q set Master,0 5%+ unmute")
</code></p>

<h2 id="the-problem">The Problem</h2>

<p>The problem was that XMonad would only react to the Right Control key (Volume Up). However, <code>xev</code> correctly interpreted the keys as having been bound to the <code>XF86Audio*</code> keys. I was really confused as to why the binds apparently did work at the system level but only one of them worked at the window manager level.</p>

<p>To rule out that it wasn’t something with the system-level (xmodmap) binds, I decided to check if it worked in <a href="http://awesome.naquadah.org/">Awesome</a>:</p>

<p>``` lua
awful.key({}, “XF86AudioLowerVolume”, function () awful.util.spawn(“amixer -q set Master,0 5%- unmute”, false) end),
awful.key({}, “XF86AudioRaiseVolume”, function () awful.util.spawn(“amixer -q set Master,0 5%+ unmute”, false) end),
awful.key({}, “XF86AudioMute”, function () awful.util.spawn(“amixer set Master,0 toggle”, false) end),</p>

<p>```</p>

<p>Indeed it worked perfectly. So now I had narrowed down the problem to XMonad.</p>

<h2 id="bug-hunting">Bug Hunting</h2>

<p>Eventually I decided to stop by <code>#xmonad</code> on freenode. There I found Paul Fertser who spent the next ~6 hours helping me track down what he figured to be a bug in XMonad. I told him that the system-level binds did work, but not in XMonad. I showed him my binds using <code>xmodmap -pke</code>.</p>

<p>He noticed that the <code>XF86Audio*</code> keys were bound twice: once by default by XKB (<code>xmodmap</code>’s more modern replacement) bound to the keycodes I would have if my keyboard had media keys, and bound again to the keys I chose (the bottom right keys). He then hypothesized that XMonad wasn’t grabbing the keys at all due to Xlib limitations. Specifically, the <code>XKeysymToKeycode</code> function only returns one keycode per key, biased towards lower keycodes, presumably due to an increasing iterative search of the keycodes for a match.</p>

<p>This theory accounted for why the Right Control (Volume Up) bind did work and not the others. What happened was that Right Control’s keycode was lower than the duplicate bind’s keycode. As a result, when XMonad used <code>XKeysymToKeycode</code> it retrieved the correct keycode. The other two binds, however, have higher keycodes than the default-bound ones, and so <code>XKeysymToKeycode</code> returned the first (lower) keycode it found and as a result XMonad never even knew of the other binds’ existence.</p>

<p>To test this theory, Paul had me run <a href="http://en.wikipedia.org/wiki/Ltrace"><code>ltrace</code></a> on XMonad to see which keys XMonad grabbed. The output of this clearly showed that XMonad only grabbed the keys with the lower keycodes.</p>

<h2 id="workaround">Workaround</h2>

<p>Now that we were pretty sure of the cause of this, the workaround was to remove the other keycodes (for keys I didn’t even have on my keyboard). At this time I decided I might as well switch over to XKB. The first order of business was to <a href="http://unix.stackexchange.com/a/65600/10163">dump my XKB map</a>:</p>

<p><code>bash
$ setxkbmap -print &gt; ~/.xkb/keymap/mymap
</code></p>

<p>Then I created a <code>~/.xkb/symbols/volume_keys</code> file to store my media key binds. It took me a long while to figure out how to remove/unbind the default-bound keys. One problem was that XKB sets different aliases for keys. For example, <code>&lt;I0D&gt;</code> (I guess that’s a media key) was aliased to <code>&lt;MUTE&gt;</code>. I looked around in <code>/usr/share/X11/xkb/rules/evdev</code> to see what was aliased and made sure to unbind those too. As for unbinding, at first Paul suggested to bind the keys to <code>NoSymbol</code> but that apparently had no effect. Eventually I found out it was possible with <a href="http://madduck.net/docs/extending-xkb/#attaching_symbols_to_keys"><code>VoidSymbol</code></a>.</p>

<p>``` plain
partial modifier_keys
xkb_symbols “volume_keys” {
  // mute
  replace key <mute> { [ VoidSymbol ] };
  replace key <i0d> { [ VoidSymbol ] };</i0d></mute></p>

<p>// lower volume
  replace key <vol-> { [ VoidSymbol ] };
  replace key <i0e> { [ VoidSymbol ] };</i0e></vol-></p>

<p>// raise volume
  replace key &lt;VOL+&gt; { [ VoidSymbol ] };
  replace key <i0f> { [ VoidSymbol ] };</i0f></p>

<p>replace key <rctl> { [ XF86AudioRaiseVolume ] };
  replace key &lt;MENU&gt; { [ XF86AudioLowerVolume ] };
  replace key <rwin> { [ XF86AudioMute ] };
  replace key <ralt> { [ Multi_key ] };
};
```</ralt></rwin></rctl></p>

<p>Now I loaded my XKB map in <code>~/.xinitrc</code>:</p>

<p><code>bash
xkbcomp -I$HOME/.xkb ~/.xkb/keymap/mymap $DISPLAY
</code></p>

<p>I restarted XMonad with <code>Mod-Shift-Q</code> (so that <code>~/.xinitrc</code> is rerun) and everything now worked perfectly.</p>

<h2 id="bug-report">Bug Report</h2>

<p>Over the course of my transition to XKB, Paul found that there was already <a href="https://code.google.com/p/xmonad/issues/detail?id=273">an issue</a> opened back in 2009 concerning this. The issue report has a patch attached that fixes this, but the patch has yet to be applied to XMonad. Paul suggested I try the patch myself and communicate my results back to the issue report. So I went ahead and got XMonad and XMonadContrib from the darcs repository, ran a simple <code>darcs apply keycode.dpatch</code>, and installed each with a <code>--prefix</code> to prevent clashing with the ones already installed with pacman. Indeed, the patch worked perfectly.</p>

]]></content>
  </entry>
  
</feed>
